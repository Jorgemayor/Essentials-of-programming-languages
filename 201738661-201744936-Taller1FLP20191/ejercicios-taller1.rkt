#lang eopl
; Taller 1 Fundamentos de lenguaje de programacion
; 
; Desarrolladores:
; 
; Jorge Eduardo Mayor Fernandez
; Codigo: 201738661
; 
; Juan Sebastian Velasquez Acevedo
; Codigo: 201744936

;--------------------------------------------------------------------------------------------------
; Point 1
; ;copy: numero {number}
; ;      elemento {any}
; ;      -> list
; ;Purpose:
; ;Copies a given element as many times as the user says.

(define copy
  (lambda(n x)
    (if (= n 0)
        empty
        (cons x (copy(- n 1) x))
        )
    )
  )

;Pruebas
(copy 7 'seven)
(copy 0 'hi)
(copy 2 '(1 2 3))

;--------------------------------------------------------------------------------------------------
; Point 2
; ;list-tails: lista {list}
; ;            -> list
; ;Purpose:
; ;Returns a list with all the sublists of the input

(define list-tails
  (lambda (lista)
    (cond [(null? lista) empty]
          [else (append (list lista) (list-tails (cdr lista)))]
          )
    )
  )

;Pruebas
(list-tails '(1 2 3 4 5))
(list-tails '(1 a '(e 4) 5 v))

;--------------------------------------------------------------------------------------------------
; Point 3
; ;list-set: lista {list}
; ;          numero {number}
; ;          elemento {any}
; ;          -> {list}
; ;Purpose:
; ;Sets an argument in the especified position,
; ;replacing the current one.

(define list-set
  (lambda (lista numero elemento)
    (cond [(null? lista) (list elemento)]
          [(= 0 numero) (cons elemento (cdr lista))]
          [else (cons (car lista) (list-set (cdr lista) (- numero 1) elemento))]
          )
    )
  )

;Pruebas
(list-set '(a b c d) 2 '(1 2))
(list-set '(a b c d) 3 '(1 5 10))
(list-set '() 0 '(1 2))

;--------------------------------------------------------------------------------------------------
; Point 4
; ;exists?: predicado {predicate}
; ;         lista {list}
; ;         -> {boolean}
; ;Purpose:
; ;Returns #t if any of the list's elements satisfies
; ;the predicate, otrehwise returns false

(define exists?
  (lambda (predicado lista)
    (cond [(null? lista) #f]
          [(predicado (car lista)) #t]
          [else (exists? predicado (cdr lista))]
          )
    )
  )

;Pruebas
(exists? number? '(a b c 3 e))
(exists? number? '(a b c d e))

;--------------------------------------------------------------------------------------------------
; Point 5
; ;list-index: predicado {predicate}
; ;            lista {list}
; ;            -> {boolena}|{number}
; ;Purpose:
; ;Returns the first element's index of the list that satisfies
; ;the predicate. If no one satisfy it, returns #f

(define list-index
  (lambda (predicado lista)
    (letrec ([getIndex (lambda (copiaLista)
                         (cond [(null? copiaLista) 0]
                               [(predicado (car copiaLista)) 0]
                               [else (+ (getIndex (cdr copiaLista)) 1)]
                               )
                         )]
             [index (getIndex lista)]
             [main (cond [(= (length lista) index) #f]
                         [else index])]
             )
      main)
    )
  )

;Pruebas
(list-index number? '(a 2 (1 3) b 7))
(list-index symbol? '(a '(b c) 17 "foo"))
(list-index symbol? '(1 2 '(a b) 3))

;--------------------------------------------------------------------------------------------------
; Point 6
; ;list-facts: numero {number}
; ;            -> {list}
; ;Purpose:
; ;Given a number, the function returns a list with
; ;all the facotrial numbers until the one given.

(define list-facts
  (lambda (numero)
    (letrec ([getFacts (lambda (numeroActual acumulado)
                         (cond [(= 0 numeroActual) (list 1)]
                               [(= numeroActual numero) (list (* acumulado numeroActual))]
                               [else (cons (* acumulado numeroActual) (getFacts (+ numeroActual 1) (* acumulado numeroActual)))]
                               )
                         )]
             [main (getFacts 1 1)]
             )
      main)
    )
  )

;Pruebas
(list-facts 5)
(list-facts 8)

;--------------------------------------------------------------------------------------------------
; Point 7
; ;cartesian-product: lista1 {list}
; ;                   lista2 {list}
; ;                   -> {list}
; ;Purpose:
; ;Returns a list of tuples generated by the
; ;cartesian product between the two lists given.

(define cartesian-product
  (lambda (lista1 lista2)
    (letrec ([getTuples (lambda (copiaLista1 copiaLista2)
                          (cond [(null? copiaLista1) empty]
                                [(null? copiaLista2) (getTuples (cdr copiaLista1) lista2)]
                                [else (cons (list (car copiaLista1) (car copiaLista2))
                                            (getTuples copiaLista1 (cdr copiaLista2)))])
                          )]
             [main (getTuples lista1 lista2)])
      main)
    )
  )

;Pruebas
(cartesian-product '(a b c) '(x y))
(cartesian-product '(p q r) '(5 6 7))

;--------------------------------------------------------------------------------------------------
; Point 8
; ;mapping: funcion {procedure}
; ;         lista1 {list}
; ;         lista2 {list}
; ;         -> {list}
; ;Purpose:
; ;Returns a list of tuples that fits with the definition of
; ;a unitary function, comparing a pair of lists, component
; ;by componennt.
; ;If the image of the function matches with the pre-image, the
; ;tuple will be paired.

(define mapping
  (lambda (funcion lista1 lista2)
    (cond [(null? lista1) empty]
          [(= (car lista2) (funcion (car lista1)))
           (cons (list (car lista1) (car lista2)) (mapping funcion (cdr lista1) (cdr lista2)))]
          [else (mapping funcion (cdr lista1) (cdr lista2))]
          )
    )
  )

;Pruebas
(mapping (lambda (d) (* d 2)) (list 1 2 3) (list 2 4 6))
(mapping (lambda (d) (* d 3)) (list 1 2 2) (list 2 4 6))
(mapping (lambda (d) (* d 2)) (list 1 2 3) (list 3 9 12))

;--------------------------------------------------------------------------------------------------
; Point 9
; ;inversions: lista {list} 
; ;            -> {number}
; ;Purpose:
; ;Finds the number of inversions of the list
; ;The function makes copies of the list to improve its
; ;efficiency.

(define inversions
  (lambda (lista)
    (letrec ([counter (lambda (numeroAComparar primeraCopia segundaCopia)
                        (cond [(null? segundaCopia) 0]
                              [(null? primeraCopia) (counter (car segundaCopia) (cdr segundaCopia) (cdr segundaCopia))]
                              [(> numeroAComparar (car primeraCopia)) (+ 1 (counter numeroAComparar (cdr primeraCopia) segundaCopia))]
                              [else (counter numeroAComparar (cdr primeraCopia) segundaCopia)])
                        )]
             [main (counter (car lista) (cdr lista) (cdr lista))]
             )
      main)
    )
  )

;Pruebas
(inversions '(2 3 8 6 1))
(inversions '(1 2 3 4))
(inversions '(3 2 1))

;--------------------------------------------------------------------------------------------------
; Point 10
; ;up: lista {list}
; ;    -> {list}
; ;Purpose:
; ;Returns a list applying a generalized union
; ;with the input.

(define up
  (lambda (lista)
    (cond [(null? lista) empty]
          [(list? (car lista)) (append (car lista) (up (cdr lista)))]
          [else (append (list (car lista)) (up (cdr lista)))])
    )
  )

;Pruebas
(up (list (list 1 2) (list 3 4)))
(up (list (list 'x (list 'y)) 'z))

;--------------------------------------------------------------------------------------------------
;Point 11
; ;generalMerge: lista1 {list}
; ;              lista2 {list}
; ;              funcion {procedure}
; ;              -> {list}
; ;Purpose:
; ;Merge two lists, that were previously sort.
; ;It works comparing element by element.
; ;Merge the lists with any comparing function.

(define generalMerge
  (lambda (lista1 lista2 funcion)
    (cond [(null? lista1) lista2]
          [(null? lista2) lista1]
          [(funcion (car lista1) (car lista2)) (cons (car lista1) (generalMerge (cdr lista1) lista2 funcion))]
          [else (cons (car lista2) (generalMerge (cdr lista2) lista1 funcion))])
    )
  )


; ;merge: lista1 {list}
; ;       lista2 {list}
; ;       -> {list}
; ;Purpose:
; ;Merge two lists, that were previously sort.
; ;Merge the list with the comparator "<".
; 
; ;It uses the function generalMerge as auxiliar.

(define merge
  (lambda (lista1 lista2)
    (generalMerge lista1 lista2 <)
    )
  )

;Pruebas
(merge '(1 4) '(1 2 8))
(merge '(35 62 81 90 91) '(3 83 85 90))

;--------------------------------------------------------------------------------------------------
; Point 12
; ;zip: funcion {procedure}
; ;     lista1 {list}
; ;     lista2 {list}
; ;     -> {list}
; ;Purpose:
; ;Applies a binary function over two list (that have
; ;the same size), generating a new one with the results.

(define zip
  (lambda (funcion lista1 lista2)
    (cond [(null? lista1) empty]
          [else (cons (funcion (car lista1) (car lista2)) (zip funcion (cdr lista1) (cdr lista2)))])
    )
  )

;Pruebas
(zip + '(1 4) '(6 2))
(zip * '(11 5 6) '(10 9 8))

;--------------------------------------------------------------------------------------------------
; Point 13
; ;filter-acum: cotaInferior {number}
; ;             cotaSuperior {number}
; ;             funcionBinaria {procedure}
; ;             valorAcumulado {number}
; ;             funcionUnitaria {procedure}
; ;             -> {number}
; ;Purpose:
; ;filter-acum will aply a binary function on the numbers of a
; ;given interval, only with the ones that fulfill with the unitary
; ;function.
; ;Procedure:
; ;It starts finding the first value in the interval that fulfill with the
; ;unitary function (getFirst) and continue evaluating and operating the
; ;rest of the interval (getValue).
; ;At the end, it adds the result of the operations to the acumulator.

(define filter-acum
  (lambda (cotaInferior cotaSuperior funcionBinaria valorAcumulado funcionUnitaria)
    (letrec ([getValue (lambda (cotaInferior acumulador)
                         (cond [(> cotaInferior cotaSuperior) acumulador]
                               [(funcionUnitaria cotaInferior)
                                (getValue (+ 1 cotaInferior) (funcionBinaria acumulador cotaInferior))]
                               [else (getValue (+ 1 cotaInferior) acumulador)])
                         )]
             [getFirst (lambda (cotaInferior)
                         (cond [(or (> cotaInferior cotaSuperior)
                                    (funcionUnitaria cotaInferior))
                                cotaInferior]
                               [else (getFirst (+ 1 cotaInferior))]
                               )
                         )]
             [getFirstValue (getFirst cotaInferior)]
             [main (+ valorAcumulado (getValue (+ getFirstValue 1) getFirstValue))])
      main)
    )
  )

;Pruebas
(filter-acum 1 10 + 0 odd?)
(filter-acum 1 10 + 0 even?)
(filter-acum 1 5 * 0 number?)

;--------------------------------------------------------------------------------------------------
; Point 14
; ;sort: lista {list}
; ;      funcion {procedure}
; ;      -> {list}
; ;Sorts a given list by the merge sort technic
; ;The function also receives a predicate to sort
; ;the list.
; 
; ;It uses the function generalMerge as auxiliar.

(define sort
  (lambda (lista funcion)
    (letrec ([take (lambda (lista posicion)
                     (cond [(= 0 posicion) empty]
                           [else (cons (car lista) (take (cdr lista) (- posicion 1)))]))]
             [drop (lambda (lista posicion)
                     (cond [(= 0 posicion) lista]
                           [else (drop (cdr lista) (- posicion 1))]))]
             [main (cond [(or (null? lista) (null? (cdr lista))) lista]
                         [else (generalMerge (sort (take lista (floor (/ (length lista) 2))) funcion)
                                             (sort (drop lista (floor (/ (length lista) 2))) funcion)
                                             funcion)])])
      main)
    )
  )

;Pruebas
(sort '(8 2 5 2 3) <)
(sort '(8 2 5 2 3) >)
(sort '("a" "c" "bo" "za" "lu") string>?)

;--------------------------------------------------------------------------------------------------
; Point 15
; ;path: numero {number}
; ;      arbol {list}
; ;      -> {list}|{boolean}
; ;Purpose:
; ;If there is a path to find an especific number in the
; ;tree, it will return a list with this path, it'll return
; ;#f otherwise.
; 
; ;It uses the function list-index as auxiliar

(define path
  (lambda (numero arbol)
    (letrec ([getLista (lambda (arbol)(cond [(null? arbol) (list -1)]
                                            [(= numero (car arbol)) empty]
                                            [(< numero (car arbol)) (cons "left" (getLista (cadr arbol)))]
                                            [else (cons "right" (getLista (caddr arbol)))]))]
             [lista (getLista arbol)]
             [main (cond [(list-index number? lista) #f]
                         [else lista])]
             )
      main)
    )
  )

;Pruebas
(path 17 '(14 (7 () (12 () ())) (26 (20 (17 () ()) ()) (31 () ()))))
(path 18 '(17 (13 () ()) (26 () ())))
(path 12 '())
